\documentclass[a4paper, 12pt]{article}
\usepackage{color}
\usepackage[svgnames]{xcolor}
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
\usepackage{fancybox}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{moreverb}
\usepackage[dvips]{hyperref}
\hypersetup{
colorlinks=true,
linkcolor=black,
}
\pagestyle{fancy}
\renewcommand\headrulewidth{1pt}
\fancyhead[L]{}
\fancyhead[R]{Rin C.}
\parindent=0cm

\begin{document}
~
\vfill
\textbf{\Huge{Logbook}}
\vfill

\renewcommand{\contentsname}{Table of contents}
\newpage
\chapter{EV3, Mindstorm}
\tableofcontents
\newpage

\subsection{Basic informations}

\textbf{Project} : Mindstorms\\
\textbf{Used model} : EV3\\
\textbf{Firmware} : leJOS EV3 0.9.1-beta (2015-11-16)\\
\textbf{Java version} : 7\\
ARMv5 Linux - Headless EABI, SoftFP ABI, Little Endian\\
\begin{center}
\includegraphics[scale=0.05]{profil} \hspace{0.5cm} \includegraphics[scale=0.05]{side}
\end{center}

\newpage
\subsection{Running the motor}

First, use a cable to connect the motor to the brick, use the motor ports (the ones behind : A, B, C or D). The Java code is pretty simple to run it, create an instance of the motor then indicate the rotation's degree :
\\ \\
\shadowbox{
\begin{minipage}[c]{15cm}
\begin{verbatim}
RegulatedMotor motor = new EV3LargeRegulatedMotor(MotorPort.A);
motor.rotate(360);
\end{verbatim}
\end{minipage}
}

\subsection{Using the color sensor}

Considering the highest point of the color sensor, the distance to the ground used is about 7 cm.\\
First, use a cable to connect the color sensor to the brick, use the color sensor ports (the ones in front : 1, 2, 3 or 4). Then, create an instance of it :
\\ \\
\shadowbox{
\begin{minipage}[c]{15cm}
\begin{verbatim}
EV3ColorSensor colorSensor = new EV3ColorSensor(SensorPort.S1);
\end{verbatim}
\end{minipage}
}

\subsubsection{Fetching RGB from the sensor}

The method to use is \textbf{getRGBMode} from \textbf{EV3ColorSensor} class. It returns a \textbf{SampleProvider} :
\\ \\
\shadowbox{
\begin{minipage}[c]{15cm}
\begin{verbatim}
SampleProvider sampleProvider = colorSensor.getRGBMode();
\end{verbatim}
\end{minipage}
}
\\ \\
The RGB is contained in this provider, now, you can fetch it :
\\ \\
\shadowbox{
\begin{minipage}[c]{15cm}
\begin{verbatim}
float[] sample = new float[sampleProvider.sampleSize()];
sampleProvider.fetchSample(sample, 0);
\end{verbatim}
\end{minipage}
}
\\ \\
The variable \textbf{sample} contains the RGB values as followed :
\begin{center}
\begin{tabular}{|c|c|}
\hline 
sample[0] & red \\ 
\hline 
sample[1] & green \\ 
\hline 
sample[2] & blue \\ 
\hline 
\end{tabular}
\end{center}

\subsubsection{Using the values}

The returned value's type is float and is between 0 and 1, this is why in this case, the values are multiplied by 1000 :
\\ \\
\shadowbox{
\begin{minipage}[c]{15cm}
\begin{verbatimtab}
for (int i = 0 ; i < sample.length ; i++) {
	sample[i] = sample[i] * 1000;
}
\end{verbatimtab}
\end{minipage}
}
The next step is maybe an error of procedure, if something is irrelevant, investigate here first. In order to manipulate integers, the sample's values are rounded to the inferior unit :
\\ \\
\shadowbox{
\begin{minipage}[c]{15cm}
\begin{verbatimtab}
int[] rgb = new int[sample.length];
for (int i = 0 ; i < rgb.length ; i++) {
	rgb[i] = (int) sample[i];
}
\end{verbatimtab}
\end{minipage}
}
\\ \\
This may be the source of corrupted data, though.

\subsubsection{Test : RGB of some colors}

The colors used are either from felt-tip markers or from crayons. The following RGB has been calculated on four tests, taking the average from these tests.
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline 
COLOR & R & G & B \\ 
\hline 
white & 38 & 41 & 24 \\ 
\hline 
red & 44 & 13 & 10 \\ 
\hline 
lightblue & 17 & 39 & 27 \\ 
\hline 
lightgreen & 24 & 34 & 16 \\ 
\hline 
yellow & 35 & 38 & 24 \\ 
\hline 
pink & 36 & 36 & 23 \\ 
\hline 
black & 19 & 18 & 10 \\ 
\hline 
greensky & 15 & 24 & 13 \\ 
\hline 
\end{tabular}\\
\vspace{0.5cm}
Felt-tip markers
\end{center}
As you can see, yellow and pink's RGB are quite too close. It could be an error due to the procedure, though. Here is the result for the crayon :
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline 
COLOR & R & G & B \\ 
\hline 
orange & 26 & 18 & 9 \\ 
\hline 
pink & 29 & 23 & 14 \\ 
\hline 
light violet & 27 & 18 & 12 \\ 
\hline 
violet & 19 & 18 & 13 \\ 
\hline 
green & 12 & 26 & 10 \\ 
\hline 
yellow & 26 & 23 & 9 \\ 
\hline 
\end{tabular} 
\end{center}

\subsubsection{New values of RGB (1)}

The method \textbf{getRGBMode} returns RGB values between 0 and 1. In previous tests, the output value was resize, scaling was 1000. A bad practice was casting those values into int : some colors had the same RGB. This time, values are kept as float with 4 digits and the scaling is 2055. Here's the result :
\begin{align}
\begin{tabular}{|c|c|c|c|}
\hline 
 & R & G & B \\ 
\hline 
\text{Black} & 24.1765 & 22.6654 & 12.0882 \\ 
\hline 
\text{Blue} & 26.6948 & 33.2426 & 27.1985 \\ 
\hline 
\text{Red} & 75.0477 & 23.6728 & 11.5755 \\ 
\hline 
\text{Yellow} & 61.9497 & 50.8713 & 13.5992 \\ 
\hline 
\text{White} & 62.9570 & 69.5073 & 37.7757 \\ 
\hline 
\end{tabular} 
\end{align}
Observation : sometimes, during testing, yellow and white might get mixed up. One possible solution would be increasing the scaling to get values with greater range.

\subsubsection{Detecting the color}

Given a RGB value, one has to know to which color is that RGB value is the closest.\\
The algorithm takes as input a RGB value and return the closest RGB (from a list of known RGB values). The idea is to consider those RGB values as space coordinates in $\R^3$. Then, calculating \textbf{the Euclidean distance}$^1$ from each known point and keeping the closest in memory.
\\ \\
\shadowbox{
\begin{minipage}[c]{15cm}
\begin{verbatimtab}
Data : a list L containing known points
Input : the point T to test
Output : the closest point to T in L

ALGORITHM
theClosestPoint = L[0]
referenceDistance = euclideanDistance(T, theClosestPoint)

for each point P in L\L[0]:
	currentDistance <- euclideanDistance(P, T)
	if (currentDistance < referenceDistance) then
		theClosestPoint <- P
		referenceDistance <- currentDistance		
return theClosestPoint
\end{verbatimtab}
\end{minipage}
}
\\ \\
Observation : the algorithm's complexity is $\mathscr{O}(n)$, each point is processed once. This algorithm is not efficient in every case, let's assume that only red and blue are known i.e. RED = (255, 0, 0) and BLUE = (0,255,0), if the given point is (0, 0, 0), this algorithm will return the last processed point that has verified the condition. Assuming the known points are sufficiently spread out, meaning their RGB values are not closer, there shouldn't be a problem. But keep in mind that an unexpected behavior may occur if the processed point is exactly placed from the same distance to a point $P_1$ and to a point $P_2$.
\\ \\
\textbf{Euclidean distance}$^1$. Let's assume that $p_1 = (x_1, y_1, z_1) \in \R^3$ and\\$p_2~=~(x_2, y_2, z_2)~\in~\R^3$ then the Euclidean distance $D$ is given by :
\begin{align}
D = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2 + (z_2 - z_1)^2}
\end{align}

\subsubsection{New values of RGB (2)}
Some colors were quite closer, the scaling was adjusted to 6055. The new valures are :
\begin{align}
\begin{tabular}{|c|c|c|c|}
\hline 
 & R & G & B \\ 
\hline 
\text{Black} & 56.9882 & 48.6775 & 30.8686 \\ 
\hline 
\text{Blue} & 74.7970 & 108.0402 & 85.4821 \\ 
\hline 
\text{Red} & 185.9241 & 73.8454 & 45.5905 \\ 
\hline 
\text{Yellow} & 176.0937 & 129.9328 & 37.6129 \\ 
\hline 
\text{White} & 134.0998 & 150.7814 & 77.1716 \\ 
\hline 
\end{tabular}
\end{align}

\subsection{Following a straight line}

The brick has to follow a line i.e. following the line until it ends. A basic idea is to move forward while the color sensor detects the same color as the line's color.
\\ \\
\shadowbox{
\begin{minipage}[c]{13cm}
\begin{verbatimtab}
Data : the color of the line, C
Input : a continuous flow of RGB

ALGORITHM
boolean isOnTheLine <- true
while (isOnTheLine):
	move foward
	currentColor <- RGB
	if not (currentColor is the same color as C) then:
		isOnTheLine <- false
\end{verbatimtab}
\end{minipage}
}
\end{document}